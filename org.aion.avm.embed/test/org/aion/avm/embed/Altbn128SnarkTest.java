package org.aion.avm.embed;

import avm.Address;
import avm.Blockchain;
import org.aion.avm.tooling.ABIUtil;
import org.aion.avm.tooling.abi.Callable;
import org.aion.avm.userlib.abi.ABIDecoder;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.ClassRule;
import org.junit.Test;

import java.math.BigInteger;


public class Altbn128SnarkTest {
    @ClassRule
    public static AvmRule avmRule = new AvmRule(true);

    private static Address sender = avmRule.getPreminedAccount();
    private static Address g16Contract;

    @BeforeClass
    public static void deployDapp() {
        byte[] g16DappBytes = avmRule.getDappBytes(G16SquarePreimage.class, null, 1,
                Fp.class, Fp2.class, G1.class, G1Point.class, G2.class, G2Point.class, Pairing.class);
        g16Contract = avmRule.deploy(sender, BigInteger.ZERO, g16DappBytes).getDappAddress();
    }

    // positive test-case for square pre-image verifier: a=337, b=113569 (a^2 == b)
    @Test
    public void g16TestVerify() {
        G1Point a = new G1Point(
                new Fp(new BigInteger("07f4a1ab12b1211149fa0aed8ade3442b774893dcd1caffb8693ade54999c164", 16)),
                new Fp(new BigInteger("23b7f10c5e1aeaffafa088f1412c0f307969ba3f8f9d5920214a4cb91693fab5", 16)));

        G2Point b = new G2Point(
                new Fp2(
                        new BigInteger("0x079ee30e2c79e15be67645838a3177f681ab111edacf6f4867e8eed753ed9681", 16),
                        new BigInteger("0x1f6cc814cf1df1ceb663378c496f168bcd21e19bb529e90fcf3721f8df6b4128", 16)),
                new Fp2(
                        new BigInteger("0x20105b11ae5fbdc7067102d4260c8913cdcb512632680221d7644f9928a7e51d", 16),
                        new BigInteger("0x2779dd0accaa1391e29ad54bf065819cac3129edda4eaf909d6ea2c7495a47f7", 16)));

        G1Point c = new G1Point(
                new Fp(new BigInteger("153c3a313679a5c11010c3339ff4f787246ed2e8d736efb615aeb321f5a22432", 16)),
                new Fp(new BigInteger("06691d8441c35768a4ca87a5f5ee7d721bf13115d2a16726c12cda295a19bf09", 16)));


        BigInteger[] input = new BigInteger[2];
        input[0] = new BigInteger("000000000000000000000000000000000000000000000000000000000001bba1", 16);
        input[1] = new BigInteger("0000000000000000000000000000000000000000000000000000000000000001", 16);

        byte[] txData = ABIUtil.encodeMethodArguments("verify", input, new Proof(a, b, c));
        AvmRule.ResultWrapper r = avmRule.call(sender, g16Contract, BigInteger.ZERO, txData);

        // transaction should succeed
        Assert.assertTrue(r.getReceiptStatus().isSuccess());
        // verify should return "true"
        Assert.assertTrue(new ABIDecoder(r.getTransactionResult().copyOfTransactionOutput().orElseThrow()).decodeOneBoolean());
    }

    // negative test-case for square pre-image verifier: a=337, b=113570 (a^2 != b)
    @Test
    public void g16TestReject() {
        G1Point a = new G1Point(
                new Fp(new BigInteger("1946d8503f2bddd05511bfcebc502a620055b4c3d2c3c104e5c473d15b789a80", 16)),
                new Fp(new BigInteger("1d1f8fffa65efb700e695f25f2a932385c144e7e964c85b9d74cca78672834ec", 16)));

        G2Point b = new G2Point(
                new Fp2(
                        new BigInteger("1af73fa504d700c6e2f7730940a0139319264a6463c4303878aab72cf0e5e2b2", 16),
                        new BigInteger("2354063529fbbd0688744273b329b6b3d6a6f9d7a837dccb1617cb0e52d72609", 16)),
                new Fp2(
                        new BigInteger("0c48749defa64ff75dd86b4cf4efaa5a4c45ed17ca25efb8ea9b183eccee1303", 16),
                        new BigInteger("08645e9bbd3baef396dce9efcc844d79c191a2f6c1ab1c87fb3859c76da9ee43", 16)));

        G1Point c = new G1Point(
                new Fp(new BigInteger("15ee5aef1ee660c3e4abecf8c31960b4ae106918ae8d403138607413a4d75f38", 16)),
                new Fp(new BigInteger("066d8491786dbf2d5e45a4006a7252333c8ffb083e3b60d00c4c9044ae9a5760", 16)));


        BigInteger[] input = new BigInteger[2];
        input[0] = new BigInteger("000000000000000000000000000000000000000000000000000000000001bba2", 16);
        input[1] = new BigInteger("0000000000000000000000000000000000000000000000000000000000000000", 16);

        byte[] txData = ABIUtil.encodeMethodArguments("verify", input, new Proof(a, b, c));
        AvmRule.ResultWrapper r = avmRule.call(sender, g16Contract, BigInteger.ZERO, txData);

        // transaction should succeed
        Assert.assertTrue(r.getReceiptStatus().isSuccess());
        // verify should return "false"
        Assert.assertFalse(new ABIDecoder(r.getTransactionResult().copyOfTransactionOutput().orElseThrow()).decodeOneBoolean());
    }

    /**
     * Hello world example (g16). Auto-generated by Zokrates.
     *
     * Circuit accepts two arguments (private: a, public: b); generates proof for statement a^2 == b
     * (i.e. I know some 'a', such that a^2 == b, for some publicly known 'b', without revealing the value for 'a').
     */
    @SuppressWarnings("WeakerAccess")
    public static class G16SquarePreimage {

        protected static class VerifyingKey {
            public final G1Point alpha;
            public final G2Point beta;
            public final G2Point gamma;
            public final G2Point delta;
            public final G1Point[] gamma_abc;

            public VerifyingKey(G1Point alpha, G2Point beta, G2Point gamma, G2Point delta, G1Point[] gamma_abc) {
                this.alpha = alpha;
                this.beta = beta;
                this.gamma = gamma;
                this.delta = delta;
                this.gamma_abc = gamma_abc;
            }
        }

        protected static VerifyingKey verifyingKey() {
            G1Point alpha = new G1Point(
                    new Fp(new BigInteger("0019120ee247a3e5c0c710de50f86f8be890b9f8ce35591abf182f4d591db8f8", 16)),
                    new Fp(new BigInteger("087d9b6ea30dc1fefda2468a53b82005fabfcdd026cee359444642ac16e14e9c", 16))
            );
            G2Point beta = new G2Point(
                    new Fp2(new BigInteger("03beea23c38a06edc9577b174c9e046789291db7ef51251e02e053adf41d6ab1", 16),
                            new BigInteger("2c76e975c13721befe2860550097061edad5d5e6d4b55d7e0888aa4081bb1b70", 16)),
                    new Fp2(new BigInteger("15383eda06e6734eedcdea2d7564c1827bca49490452bc70374e07d13a3a38ea", 16),
                            new BigInteger("11820c74e2c88cebeb132852cb0b02fdd23cc77e2927fe70c96bee0342c11c2f", 16))
            );
            G2Point gamma = new G2Point(
                    new Fp2(new BigInteger("23d45e985239a8c7d0cd091c66fd204d530df129ebbde3cba00950360f60a0bb", 16),
                            new BigInteger("125c637232482e34cf00c0c6393bafe26e310343f4f6383cf6e65ff2a8fab351", 16)),
                    new Fp2(new BigInteger("133f401b96c4165c139e22e7dadf859a3a2169485bc9f462042779b76820f444", 16),
                            new BigInteger("1bce5f9e19392c141016211714944bf88222d77059a7b8939de4d942bfb815b6", 16))
            );
            G2Point delta = new G2Point(
                    new Fp2(new BigInteger("07dcfa8f6093776cc7003f0a7655178642c624b5158f7767d446e99123569668", 16),
                            new BigInteger("2d218c6c3c97d36c6a36bdae8aaad026787d5d7bc73fcac935302901cccc8cac", 16)),
                    new Fp2(new BigInteger("1375019c6afcce46743219e2584f57fac17a99f6f105c47d77ccc15f4a12514f", 16),
                            new BigInteger("0d34b1da6e22c6fc31ad42e9165598572c98c591e03877bf398d95fc620fc7a9", 16))
            );
            G1Point[] gamma_abc = new G1Point[]{
                    new G1Point(
                            new Fp(new BigInteger("2da89765d6c25c6d0d63a767bf9d30a7e6b4c040663a8dc1a1a002085d1009c3", 16)),
                            new Fp(new BigInteger("03beb639535322312a2eace06a3ffad50e09fbd12d4762553c166d7e47b20af9", 16))
                    ),
                    new G1Point(
                            new Fp(new BigInteger("1e870e8b098c7053a851060c1d965b9e177a37c4a6c3bfa9539733ad48704871", 16)),
                            new Fp(new BigInteger("279795f70d42bfe052be9153148c6d16b63bf4564172d45666535882ffd21070", 16))
                    ),
                    new G1Point(
                            new Fp(new BigInteger("126b7087066e197fd44591d3f9f2df60fa08cc5030f38f5671a13b4bd7d0cd25", 16)),
                            new Fp(new BigInteger("1404cadb49f2910570d68c8163766e71a92676bc3f24c6118574a3ecbd4f0578", 16))
                    )
            };
            return new VerifyingKey(alpha, beta, gamma, delta, gamma_abc);
        }

        public static boolean verify(BigInteger[] input, Proof proof) {
            BigInteger snarkScalarField = new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617");
            VerifyingKey vk = verifyingKey();
            require(input.length + 1 != vk.gamma_abc.length);

            // X = gamma_0 + gamma_1 * input_0 + gamma_2 * input_1
            G1Point X = new G1Point(Fp.zero(), Fp.zero());
            for (int i = 0; i < input.length; i++) {
                require(input[i].compareTo(snarkScalarField) < 0);
                X = G1.add(X, G1.mul(vk.gamma_abc[i + 1], input[i]));
            }
            X = G1.add(X, vk.gamma_abc[0]);

            // See [Groth16]
            // [A]_1 * [B]_2 = [alpha]_1 * [beta]_2 + [X]_1 * [gamma]_2 + [C]_1 * [delta]_2
            // e(A, B)
            // e(-X, gamma)
            // e(-C, delta)
            // e(-alpha, beta)
            BigInteger prod = Pairing.pairingProd4(
                    proof.a, proof.b,
                    G1.negate(X), vk.gamma,
                    G1.negate(proof.c), vk.delta,
                    G1.negate(vk.alpha), vk.beta);

            return prod.equals(BigInteger.ONE);
        }

        @Callable
        public static boolean verify(BigInteger[] input, BigInteger[] proof) {
            require(proof.length == 2 + 4 + 2); // a in g1, b in g2, c in g1

            return verify(input, new Proof(
                    new G1Point(new Fp(proof[0]), new Fp(proof[1])),
                    new G2Point(
                            new Fp2(proof[2], proof[3]),
                            new Fp2(proof[4], proof[5])
                    ),
                    new G1Point(new Fp(proof[6]), new Fp(proof[7]))
            ));
        }

        private static void require(boolean condition) {
            if (!condition) {
                Blockchain.revert();
            }
        }
    }

    protected static class Proof {
        public final G1Point a;
        public final G2Point b;
        public final G1Point c;

        public Proof(G1Point a, G2Point b, G1Point c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }
    }

    /**
     * Represents an element of field F_p.
     */
    public static class Fp {
        public static final BigInteger FIELD_MODULUS = new BigInteger("21888242871839275222246405745257275088696311157297823662689037894645226208583");

        public final BigInteger c0;

        public Fp(BigInteger c0) {
            this.c0 = c0;
        }

        public Fp(long c0) {
            this(BigInteger.valueOf(c0));
        }

        public static Fp zero() {
            return new Fp(BigInteger.ZERO);
        }

        public boolean isZero() {
            return c0.equals(BigInteger.ZERO);
        }

        // TODO: implement field operations

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Fp2 that = (Fp2) o;
            return this.c0.equals(that.c0);
        }

        @Override
        public int hashCode() {
            return c0.hashCode();
        }
    }

    /**
     * Represents an element of the field F_p^2 (F_p[i]/(i^2 + 1)).
     */
    public static class Fp2 {
        public static final BigInteger FIELD_MODULUS = new BigInteger("30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47", 16);

        public final BigInteger c0;
        public final BigInteger c1;

        public Fp2(BigInteger c0, BigInteger c1) {
            this.c0 = c0;
            this.c1 = c1;
        }

        public static Fp2 zero() {
            return new Fp2(BigInteger.ZERO, BigInteger.ZERO);
        }

        public static Fp2 one() {
            return new Fp2(BigInteger.ONE, BigInteger.ZERO);
        }

        public boolean isZero() {
            return c0.equals(BigInteger.ZERO) && c1.equals(BigInteger.ZERO);
        }

        public Fp2 add(Fp2 that) {
            return new Fp2(
                    addmod(this.c0, that.c0, FIELD_MODULUS),
                    addmod(this.c1, that.c1, FIELD_MODULUS)
            );
        }

        public Fp2 subtract(Fp2 that) {
            return new Fp2(
                    submod(this.c0, that.c0, FIELD_MODULUS),
                    submod(this.c1, that.c1, FIELD_MODULUS)
            );
        }

        public Fp2 multiply(Fp2 that) {
            /*
             * (a + bx) * (c + dx) // 1 + x^2
             * = (ac - bd) + (ad + bc)x
             */
            return new Fp2(
                    submod(mulmod(this.c0, that.c0, FIELD_MODULUS), mulmod(this.c1, that.c1, FIELD_MODULUS), FIELD_MODULUS),
                    addmod(mulmod(this.c0, that.c1, FIELD_MODULUS), mulmod(this.c1, that.c0, FIELD_MODULUS), FIELD_MODULUS)
            );
        }

        public Fp2 multiply(BigInteger s) {
            return new Fp2(
                    mulmod(this.c0, s, FIELD_MODULUS),
                    mulmod(this.c1, s, FIELD_MODULUS)
            );
        }

        public Fp2 divide(Fp2 other) {
            return multiply(other.inverse());
        }

        public Fp2 inverse() {
            /*
             * Assume this = a + bx and inverse = c + dx, then
             * (ac - bd) + (ad + bc)x = 1, then
             * ac - bd = 1
             * ad + bc = 0.
             * Solving the above linear equations, we get
             * c = a * (a^2 + b^2)^-1
             * d = -b * (a^2 + b^2)^-1
             */
            BigInteger inv = addmod(
                    mulmod(this.c1, this.c1, FIELD_MODULUS),
                    mulmod(this.c0, this.c0, FIELD_MODULUS),
                    FIELD_MODULUS
            ).modInverse(FIELD_MODULUS);

            return new Fp2(
                    mulmod(this.c0, inv, FIELD_MODULUS),
                    FIELD_MODULUS.subtract(mulmod(this.c1, inv, FIELD_MODULUS))
            );
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Fp2 that = (Fp2) o;
            return this.c0.equals(that.c0) && this.c1.equals(that.c1);
        }

        @Override
        public int hashCode() {
            int result = 1;
            result = 31 * result + this.c0.hashCode();
            result = 31 * result + this.c1.hashCode();

            return result;
        }

        private static BigInteger addmod(BigInteger a, BigInteger b, BigInteger c) {
            return a.add(b).mod(c);
        }

        private static BigInteger submod(BigInteger a, BigInteger b, BigInteger c) {
            return a.subtract(b).mod(c);
        }

        private static BigInteger mulmod(BigInteger a, BigInteger b, BigInteger c) {
            return a.multiply(b).mod(c);
        }
    }

    /**
     * A collection of Elliptic Curve operations on G1 for alt_bn128. This implementation is
     * heavily based on the EC API exposed by the AVM.
     *
     * <p>
     * Curve definition: y^2 = x^3 + b
     * <p>
     */
    public static class G1 {

        // The prime q in the base field F_q for G1
        private static final BigInteger q = new BigInteger("21888242871839275222246405745257275088696311157297823662689037894645226208583");

        public static G1Point negate(G1Point p) {
            if (p.isZero()) {
                return new G1Point(Fp.zero(), Fp.zero());
            }
            return new G1Point(p.x, new Fp(q.subtract(p.y.c0.mod(q))));
        }

        public static G1Point add(G1Point p1, G1Point p2) {
            // TODO: Call AVM for EC addition
            return null;
        }

        public static G1Point mul(G1Point p, BigInteger s) {
            // TODO: Call AVM for EC multiplication
            return null;
        }
    }

    /**
     * Represents a point on G1.
     */
    public static class G1Point {
        public final Fp x;
        public final Fp y;

        public G1Point(Fp x, Fp y) {
            this.x = x;
            this.y = y;
        }

        public boolean isZero() {
            return x.isZero() && y.isZero();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            G2Point that = (G2Point) o;
            return this.x.equals(that.x) && this.y.equals(that.y);
        }

        @Override
        public int hashCode() {
            int result = 1;
            result = 31 * result + this.x.hashCode();
            result = 31 * result + this.y.hashCode();

            return result;
        }

        @Override
        public String toString() {
            return "(" + x.c0 + ", " + y.c0 + ")";
        }
    }

    /**
     * A collection of Elliptic Curve operations on G2 for alt_bn128.
     * <p>
     * Curve definition: y^2 = x^3 + b
     * <p>
     * Ported from https://github.com/musalbas/solidity-BN256G2/blob/master/BN256G2.sol
     */
    public static class G2 {

        public static final Fp2 TWIST_B = new Fp2(
                new BigInteger("2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5", 16),
                new BigInteger("9713b03af0fed4cd2cafadeed8fdf4a74fa084e52d1852e4a2bd0685c315d2", 16)
        );

        /**
         * Adds two points.
         *
         * @param p1 the first point
         * @param p2 the second point
         * @return p1 + p2
         */
        public static G2Point ECTwistAdd(G2Point p1, G2Point p2) {
            if (p1.isZero()) {
                if (!p2.isZero()) {
                    assert isOnCurve(p2);
                }
                return p2;
            } else if (p2.isZero()) {
                assert isOnCurve(p1);
                return p1;
            }

            assert isOnCurve(p1);
            assert isOnCurve(p2);

            G2Point p3 = ECTwistAdd(toJacobian(p1), toJacobian(p2)).toAffine();

            return p3;
        }

        /**
         * Multiplies a point by a scalar.
         *
         * @param p the point
         * @param s the multiplier
         * @return s * p
         */
        public static G2Point ECTwistMul(G2Point p, BigInteger s) {
            if (!p.isZero()) {
                assert isOnCurve(p);
            }

            G2Point p2 = ECTwistMul(toJacobian(p), s).toAffine();

            return p2;
        }

        protected static boolean isOnCurve(G2Point p) {
            Fp2 y2 = p.y.multiply(p.y); // y^2
            Fp2 x3 = p.x.multiply(p.x).multiply(p.x); // x^3
            Fp2 diff = y2.subtract(x3).subtract(TWIST_B); // y^2 - x^3 - B

            return diff.isZero();
        }

        protected static JacobianPoint ECTwistAdd(JacobianPoint p1, JacobianPoint p2) {
            if (p1.z.isZero()) {
                return p2;
            } else if (p2.z.isZero()) {
                return p1;
            }

            Fp2 U1 = p2.y.multiply(p1.z); // U1 = p2.y * p1.z
            Fp2 U2 = p1.y.multiply(p2.z); // U2 = p1.y * p2.z
            Fp2 V1 = p2.x.multiply(p1.z); // V1 = p2.x * p1.z
            Fp2 V2 = p1.x.multiply(p2.z); // V2 = p1.x * p2.z

            if (p2.x.equals(V2)) {
                if (p2.y.equals(U2)) {
                    return ECTwistDouble(p1);
                }

                return new JacobianPoint(Fp2.one(), Fp2.one(), Fp2.zero());
            }

            Fp2 W = p1.z.multiply(p2.z); // W = p1.z * p2.z
            Fp2 V = V1.subtract(V2); // V = V1 - V2
            Fp2 V_2 = V.multiply(V);
            Fp2 V_3 = V_2.multiply(V);
            // z = V^3 * W
            Fp2 z = V_3.multiply(W);

            Fp2 U = U1.subtract(U2); // U = U1 - U2
            Fp2 U_2 = U.multiply(U);
            Fp2 A = U_2.multiply(W).subtract(V_3).subtract(V_2.multiply(V2).multiply(BigInteger.TWO));
            // x = V * (U^2 * W - V^3 - 2 * V^2 * V2)
            Fp2 x = V.multiply(A);

            // y = U * (v^2 * V2 - A) - V^3 * U2
            Fp2 y = U.multiply(V_2.multiply(V2).subtract(A)).subtract(V_3.multiply(U2));

            return new JacobianPoint(x, y, z);
        }

        protected static JacobianPoint ECTwistMul(JacobianPoint p, BigInteger s) {
            JacobianPoint p2 = new JacobianPoint(Fp2.zero(), Fp2.zero(), Fp2.zero());

            while (!s.equals(BigInteger.ZERO)) {
                if (s.testBit(0)) {
                    p2 = ECTwistAdd(p2, p);
                }

                p = ECTwistDouble(p);

                s = s.divide(BigInteger.TWO);
            }

            return p2;
        }

        protected static JacobianPoint ECTwistDouble(JacobianPoint p) {
            Fp2 W = p.x.multiply(p.x).multiply(BigInteger.valueOf(3)); // W = 3 * x * x
            Fp2 S = p.y.multiply(p.z); // S = y * z
            Fp2 B = p.x.multiply(p.y).multiply(S); // B = x * y * S
            Fp2 H = W.multiply(W).subtract(B.multiply(BigInteger.valueOf(8))); // H = W * W - 8 * B
            Fp2 S_2 = S.multiply(S); // S^2
            Fp2 S_3 = S_2.multiply(S); // S^3

            // y = W * (4 * B - H) - 8 * y * y * S^2
            Fp2 y = W.multiply(B.multiply(BigInteger.valueOf(4)).subtract(H))
                    .subtract(p.y.multiply(p.y).multiply(BigInteger.valueOf(8)).multiply(S_2));
            // x = 2 * H * S
            Fp2 x = H.multiply(S).multiply(BigInteger.TWO);
            // z = 8 * S^3
            Fp2 z = S_3.multiply(BigInteger.valueOf(8));

            return new JacobianPoint(x, y, z);
        }

        protected static JacobianPoint toJacobian(G2Point p) {
            return p.isZero() ? new JacobianPoint(Fp2.one(), Fp2.one(), Fp2.zero()) : new G2.JacobianPoint(p.x, p.y, Fp2.one());
        }

        public static class JacobianPoint {
            public final Fp2 x;
            public final Fp2 y;
            public final Fp2 z;

            public JacobianPoint(Fp2 x, Fp2 y, Fp2 z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            public G2Point toAffine() {
                if (z.isZero()) {
                    return new G2Point(Fp2.zero(), Fp2.zero());
                } else {
                    Fp2 inv = z.inverse();
                    return new G2Point(x.multiply(inv), y.multiply(inv));
                }
            }

            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                JacobianPoint that = (JacobianPoint) o;
                return this.x.equals(that.x) && this.y.equals(that.y) && this.z.equals(that.z);
            }

            @Override
            public int hashCode() {
                int result = 1;
                result = 31 * result + this.x.hashCode();
                result = 31 * result + this.y.hashCode();
                result = 31 * result + this.z.hashCode();

                return result;
            }

            @Override
            public String toString() {
                return "((" + x.c0 + ", " + x.c1 + "), (" + y.c0 + ", " + y.c1 + "), (" + z.c0 + ", " + z.c1 + "))";
            }
        }
    }

    /**
     * Represents a point on the elliptic curve.
     */
    public static class G2Point {
        public final Fp2 x;
        public final Fp2 y;

        public G2Point(Fp2 x, Fp2 y) {
            this.x = x;
            this.y = y;
        }

        public boolean isZero() {
            return x.isZero() && y.isZero();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            G2Point that = (G2Point) o;
            return this.x.equals(that.x) && this.y.equals(that.y);
        }

        @Override
        public int hashCode() {
            int result = 1;
            result = 31 * result + this.x.hashCode();
            result = 31 * result + this.y.hashCode();

            return result;
        }

        @Override
        public String toString() {
            return "((" + x.c0 + ", " + x.c1 + "), (" + y.c0 + ", " + y.c1 + "))";
        }
    }

    /**
     * A library of pairing utilities.
     * <p>
     * Ported from https://github.com/Zokrates/ZoKrates/blob/master/zokrates_core/src/proof_system/bn128/g16.rs
     */
    public static class Pairing {

        /**
         * Returns the generator of G1
         */
        public static G1Point P1() {
            return new G1Point(new Fp(1), new Fp(2));
        }

        /**
         * Returns the generator of G2
         */
        public static G2Point P2() {
            return new G2Point(
                    new Fp2(
                            new BigInteger("11559732032986387107991004021392285783925812861821192530917403151452391805634"),
                            new BigInteger("10857046999023057135944570762232829481370756359578518086990519993285655852781")
                    ),
                    new Fp2(
                            new BigInteger("4082367875863433681332203403145435568316851327593401208105741076214120093531"),
                            new BigInteger("8495653923123431417604973247489272438418190587263600148770280649306958101930")
                    )
            );
        }

        /**
         * Bilinear pairing check.
         *
         * @param p1
         * @param p2
         * @return
         */
        public static BigInteger pairing(G1Point[] p1, G2Point[] p2) {
            if (p1.length != p2.length) {
                throw new IllegalArgumentException("Points are not in pair");
            }

            int size = p1.length * 6;
            BigInteger[] pairs = new BigInteger[size];
            for (int i = 0; i < p1.length; i++) {
                pairs[i * 6 + 0] = p1[i].x.c0;
                pairs[i * 6 + 1] = p1[i].y.c0;
                pairs[i * 6 + 2] = p2[i].x.c0;
                pairs[i * 6 + 3] = p2[i].x.c1;
                pairs[i * 6 + 4] = p2[i].y.c0;
                pairs[i * 6 + 5] = p2[i].y.c1;
            }

            // TODO: call AVM for pairing check

            return BigInteger.ONE;
        }

        public static BigInteger pairingProd2(G1Point a1, G2Point a2, G1Point b1, G2Point b2) {
            return pairing(new G1Point[]{a1, b1}, new G2Point[]{a2, b2});
        }

        public static BigInteger pairingProd3(G1Point a1, G2Point a2, G1Point b1, G2Point b2, G1Point c1, G2Point c2) {
            return pairing(new G1Point[]{a1, b1, c1}, new G2Point[]{a2, b2, c2});
        }

        public static BigInteger pairingProd4(G1Point a1, G2Point a2, G1Point b1, G2Point b2, G1Point c1, G2Point c2, G1Point d1, G2Point d2) {
            return pairing(new G1Point[]{a1, b1, c1, d1}, new G2Point[]{a2, b2, c2, d2});
        }
    }
}
